<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ›‘ å¤šå±¤é›£èª­åŒ–ãƒ„ãƒ¼ãƒ« [Parser Edition]</title>
  <style>
    body { font-family: 'Consolas', 'Monaco', monospace; background: #101010; color: #0f0; padding: 20px; }
    .container { max-width: 1000px; margin: auto; background: #000; padding: 20px; border: 1px solid #0f0; border-radius: 8px; box-shadow: 0 0 15px #002200; }
    h1 { text-align: center; margin-top: 0; color: #fff; text-shadow: 0 0 10px #0f0; }
    .subtitle { text-align: center; color: #8f8; font-size: 0.85em; margin-bottom: 20px; }
    textarea, #output { width: 100%; background: #181818; color: #ccc; border: 1px solid #333; padding: 15px; box-sizing: border-box; height: 180px; font-size: 13px; font-family: inherit; }
    textarea:focus, #output:focus { outline: 2px solid #050; border-color: #0f0; color: #fff; }
    #output { min-height: 200px; white-space: pre-wrap; word-break: break-all; color: #cfc; }
    
    .controls { display: flex; gap: 15px; justify-content: center; margin: 20px 0; }
    button { padding: 10px 25px; background: #003300; color: #0f0; border: 1px solid #0f0; cursor: pointer; font-weight: bold; font-family: inherit; transition: 0.2s; }
    button:hover { background: #005500; box-shadow: 0 0 10px #0f0; }
    
    .options { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; padding: 15px; background: #0a0a0a; border: 1px solid #333; margin-bottom: 15px; }
    label { display: flex; align-items: center; cursor: pointer; user-select: none; }
    input[type="checkbox"] { accent-color: #0f0; margin-right: 8px; }
    
    #statusText { font-weight: bold; margin-left: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ›‘ å¤šå±¤é›£èª­åŒ–ãƒ„ãƒ¼ãƒ« [Parser Edition]</h1>
    <p class="subtitle">ç°¡æ˜“ãƒ‘ãƒ¼ã‚µãƒ¼æ­è¼‰ï¼šæ­£è¦è¡¨ç¾ãƒªãƒ†ãƒ©ãƒ« / æ–‡å­—åˆ— / å‰²ã‚Šç®—ã‚’æ­£ç¢ºã«è­˜åˆ¥</p>

    <textarea id="input" placeholder="// ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„
const regex = /&quot;/g; // æ­£è¦è¡¨ç¾å†…ã®ã‚¯ã‚©ãƒ¼ãƒˆã‚‚å®‰å…¨
const div = 10 / 2;    // å‰²ã‚Šç®—ã‚‚å®‰å…¨
console.log(`Result: ${div}`);">
// é›£èª­åŒ–ãƒ†ã‚¹ãƒˆ
var magic = 10 / 2;
var reg = /"/g; // ã‚¯ã‚©ãƒ¼ãƒˆã‚’å«ã‚€æ­£è¦è¡¨ç¾
var text = 'He said "Hello"';

if (text.match(reg)) {
  console.log(`Match found! Value: ${magic}`);
}
</textarea>

    <div class="options">
      <div><strong>å±¤æ•°: <input type="range" id="layers" min="1" max="3" value="1"> <span id="layerVal">1</span></strong></div>
      <label><input type="checkbox" id="renameVars" checked> å¤‰æ•°åãƒªãƒãƒ¼ãƒ </label>
      <label><input type="checkbox" id="stringEscape" checked> æ–‡å­—åˆ—é›£èª­åŒ– (\xHH)</label>
      <label><input type="checkbox" id="numberSafe" checked> æ•°å€¤HexåŒ–</label>
      <label><input type="checkbox" id="wrapEval" checked> Evalåœ§ç¸® (JSON)</label>
    </div>

    <div class="controls">
      <button onclick="processObfuscation()">ğŸ’€ é›£èª­åŒ–å®Ÿè¡Œ</button>
      <button onclick="copyToClip()">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
      <button onclick="runTest()" style="border-color:#f55; color:#fcc;">ğŸš¨ å®Ÿè¡Œãƒ†ã‚¹ãƒˆ</button>
    </div>

    <div style="text-align:center; color:#888;">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: <span id="statusText">å¾…æ©Ÿä¸­</span></div>
    <pre id="output"></pre>
  </div>

<script>
let finalCode = "";

/**
 * ã‚³ãƒ¼ãƒ‰ã‚’è§£æã—ã€æ–‡å­—åˆ—ãƒ»æ­£è¦è¡¨ç¾ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆã‚’ãƒã‚¹ã‚¯ã™ã‚‹ç°¡æ˜“ãƒ‘ãƒ¼ã‚µãƒ¼
 * ã“ã‚Œã«ã‚ˆã‚Š / / (å‰²ã‚Šç®—) ã¨ / / (æ­£è¦è¡¨ç¾) ã‚’åŒºåˆ¥ã—ã€
 * "æ–‡å­—åˆ—" ã‚„ `ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ` ã‚’ä¿è­·ã—ã¾ã™ã€‚
 */
function maskLiterals(code) {
  let output = "";
  const store = [];
  let i = 0;
  const len = code.length;

  // ç›´å‰ã®æœ‰åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ãŒä½•ã ã£ãŸã‹ï¼ˆæ­£è¦è¡¨ç¾vså‰²ã‚Šç®—ã®åˆ¤å®šã«ä½¿ã†ï¼‰
  // trueãªã‚‰ã€Œå€¤(identifier/number/close-paren)ã€ã®ç›´å¾Œ -> æ¬¡ã® / ã¯å‰²ã‚Šç®—
  // falseãªã‚‰ã€Œæ¼”ç®—å­/é–‹å§‹ã‚«ãƒƒã‚³/ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€ã®ç›´å¾Œ -> æ¬¡ã® / ã¯æ­£è¦è¡¨ç¾
  let lastIsValue = false; 

  function addPlaceholder(content, type) {
    const id = store.length;
    store.push({ type, content });
    output += `___TOK_${type}_${id}___`;
  }

  while (i < len) {
    const char = code[i];
    const next = code[i+1] || "";

    // 1. ã‚³ãƒ¡ãƒ³ãƒˆã®å‡¦ç† (å‰Šé™¤å¯¾è±¡)
    if (char === '/' && next === '/') {
      let start = i;
      i += 2;
      while (i < len && code[i] !== '\n') i++;
      // è¡Œã‚³ãƒ¡ãƒ³ãƒˆã¯å‰Šé™¤ (æ”¹è¡Œã¯æ®‹ã™)
      output += "\n"; 
      lastIsValue = false; // æ”¹è¡Œå¾Œã¯ãƒªã‚»ãƒƒãƒˆ
      continue;
    }
    if (char === '/' && next === '*') {
      i += 2;
      while (i < len && !(code[i] === '*' && code[i+1] === '/')) i++;
      i += 2;
      // ãƒ–ãƒ­ãƒƒã‚¯ã‚³ãƒ¡ãƒ³ãƒˆå‰Šé™¤
      output += " ";
      continue;
    }

    // 2. æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ« (' " `)
    if (char === '"' || char === "'" || char === '`') {
      const quote = char;
      let start = i;
      i++;
      while (i < len) {
        if (code[i] === '\\') {
          i += 2; // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚¹ã‚­ãƒƒãƒ—
          continue;
        }
        if (code[i] === quote) {
          i++;
          break;
        }
        i++;
      }
      const content = code.slice(start, i);
      // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒªãƒ†ãƒ©ãƒ«(`)ã‹é€šå¸¸æ–‡å­—åˆ—(STR)ã‹
      const type = (quote === '`') ? 'TMPL' : 'STR';
      addPlaceholder(content, type);
      lastIsValue = true; // æ–‡å­—åˆ—ã¯å€¤æ‰±ã„
      continue;
    }

    // 3. æ­£è¦è¡¨ç¾ãƒªãƒ†ãƒ©ãƒ« vs å‰²ã‚Šç®—
    if (char === '/') {
      // ç›´å‰ãŒå€¤(å¤‰æ•°ã‚„æ•°å­—)ãªã‚‰ã€ã“ã‚Œã¯å‰²ã‚Šç®—(æ¼”ç®—å­)
      if (lastIsValue) {
        output += char;
        i++;
        lastIsValue = false; // æ¼”ç®—å­ã®å¾Œã¯å€¤ã§ã¯ãªã„
        continue;
      } else {
        // ç›´å‰ãŒæ¼”ç®—å­ã‚„åŒºåˆ‡ã‚Šæ–‡å­—ãªã‚‰ã€ã“ã‚Œã¯æ­£è¦è¡¨ç¾ãƒªãƒ†ãƒ©ãƒ«ã®é–‹å§‹
        let start = i;
        i++;
        let inClass = false; // [...] ã®ä¸­ã‹ã©ã†ã‹
        while (i < len) {
          if (code[i] === '\\') {
            i += 2;
            continue;
          }
          if (code[i] === '[') {
            inClass = true;
          } else if (code[i] === ']') {
            inClass = false;
          } else if (code[i] === '/' && !inClass) {
            i++;
            // ãƒ•ãƒ©ã‚° (g, i, m...) ã‚’èª­ã¿é£›ã°ã™
            while (i < len && /^[gimsuy]/.test(code[i])) {
              i++;
            }
            break;
          }
          i++;
        }
        const regex = code.slice(start, i);
        addPlaceholder(regex, 'REGEX');
        lastIsValue = true; // æ­£è¦è¡¨ç¾ãƒªãƒ†ãƒ©ãƒ«ã¯å€¤æ‰±ã„
        continue;
      }
    }

    // 4. é€šå¸¸ã®ã‚³ãƒ¼ãƒ‰æ–‡å­—
    // ç©ºç™½ã¯ç„¡è¦–ã—ã¦çŠ¶æ…‹ç¶­æŒã€ãã‚Œä»¥å¤–ã¯çŠ¶æ…‹æ›´æ–°
    if (/\s/.test(char)) {
      output += char;
      i++;
      // lastIsValueã¯å¤‰æ›´ã—ãªã„ï¼ˆç©ºç™½ã¾ãŸãã§åˆ¤å®šã™ã‚‹ãŸã‚ï¼‰
    } else {
      output += char;
      i++;
      // è­˜åˆ¥å­(å¤‰æ•°åãƒ»æ•°å­—)ã€é–‰ã˜æ‹¬å¼§ ) ] } ã®å¾Œã¯ã€Œå€¤ã€ã¨ã¿ãªã™
      if (/[a-zA-Z0-9_$\]\)]/.test(char)) {
        lastIsValue = true;
      } else {
        // ( [ { = + - * , ; : ? ! < > ç­‰ã®å¾Œã¯ã€Œå€¤ã§ã¯ãªã„ã€
        lastIsValue = false;
      }
    }
  }

  return { output, store };
}

function obfuscateOnce(sourceCode) {
  // Step 1: ãƒ‘ãƒ¼ã‚µãƒ¼ã§ãƒªãƒ†ãƒ©ãƒ«é¡ã‚’å…¨ã¦é€€é¿
  const { output: maskedCode, store } = maskLiterals(sourceCode);
  let code = maskedCode;

  // Step 2: å¤‰æ•°åãƒªãƒãƒ¼ãƒ 
  if (document.getElementById('renameVars').checked) {
    const varMap = {};
    let varCount = 0;
    const exclude = ['window', 'document', 'console', 'alert', 'eval', 'JSON', 'Math', 'parseInt', 'setTimeout', 'setInterval', 'location'];

    code = code.replace(/\b(var|let|const|function)\s+([a-zA-Z_$][\w$]*)/g, (m, type, name) => {
      if (exclude.includes(name)) return m;
      if (!varMap[name]) {
        varMap[name] = `_0x${Math.floor(Math.random()*0xffff).toString(16)}_${varCount++}`;
      }
      return `${type} ${varMap[name]}`;
    });

    for (const [orig, neo] of Object.entries(varMap)) {
      // ãƒˆãƒ¼ã‚¯ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ (TOK_STR_0ç­‰) ã‚’å£Šã•ãªã„ã‚ˆã†æ³¨æ„
      const re = new RegExp(`(?<!\\.|[a-zA-Z0-9_$])${orig}\\b(?!\\s*:)`, 'g');
      code = code.replace(re, neo);
    }
  }

  // Step 3: æ•°å€¤HexåŒ–
  if (document.getElementById('numberSafe').checked) {
    code = code.replace(/\b(\d+)\b/g, (match) => {
      // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€å†…ã®æ•°å­—(TOK_STR_123)ã‚’å·»ãè¾¼ã¾ãªã„ãƒã‚§ãƒƒã‚¯
      if (maskedCode.includes(`_${match}_`)) return match; 
      const n = parseInt(match, 10);
      if (isNaN(n) || n < 10) return match;
      return `0x${n.toString(16)}`;
    });
  }

  // Step 4: ãƒªãƒ†ãƒ©ãƒ«ã®å¾©å…ƒ
  // ã“ã“ã§æ–‡å­—åˆ—ã ã‘é›£èª­åŒ–ã—ã€æ­£è¦è¡¨ç¾ã‚„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒªãƒ†ãƒ©ãƒ«ã¯ãã®ã¾ã¾æˆ»ã™
  const doStringEscape = document.getElementById('stringEscape').checked;

  // æ­£è¦è¡¨ç¾ã§ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã‚’æ¢ã—ã¦ç½®æ›
  code = code.replace(/___TOK_([A-Z]+)_(\d+)___/g, (match, type, id) => {
    const item = store[parseInt(id)];
    const original = item.content;

    // æ­£è¦è¡¨ç¾(REGEX) ã‚„ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ(TMPL) ã¯çµ¶å¯¾ã«ã„ã˜ã‚‰ãªã„
    if (type === 'REGEX' || type === 'TMPL') {
      return original;
    }

    // æ–‡å­—åˆ—(STR) ã®å ´åˆ
    if (type === 'STR' && doStringEscape) {
      const quote = original[0];
      const content = original.slice(1, -1);
      let out = "";
      for (let i = 0; i < content.length; i++) {
        const c = content.charCodeAt(i);
        const ch = content[i];
        if (ch === '\\') {
           // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ (\n, \", \\) ã¯ãã®ã¾ã¾ç¶­æŒ
           out += ch + (content[i+1] || '');
           i++;
           continue;
        }
        // ASCIIç¯„å›²ã®å®‰å…¨ãªæ–‡å­—ã ã‘HexåŒ–
        if (Math.random() > 0.5 && c > 31 && c < 127) {
          out += '\\x' + c.toString(16).padStart(2, '0');
        } else {
          out += ch;
        }
      }
      return quote + out + quote;
    }

    return original;
  });

  // Step 5: Evalåœ§ç¸®
  if (document.getElementById('wrapEval').checked) {
    code = `eval(${JSON.stringify(code)})`;
  }

  return code;
}

function processObfuscation() {
  const input = document.getElementById('input').value;
  if (!input.trim()) return alert("ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
  
  const status = document.getElementById('statusText');
  status.textContent = "å‡¦ç†ä¸­...";
  status.style.color = "#ff0";

  setTimeout(() => {
    try {
      let c = input;
      const layers = parseInt(document.getElementById('layers').value);
      for(let i=0; i<layers; i++) {
        c = obfuscateOnce(c);
      }
      finalCode = c;
      document.getElementById('output').textContent = finalCode;
      status.textContent = "âœ… å®Œäº†";
      status.style.color = "#0f0";
    } catch(e) {
      console.error(e);
      status.textContent = "âŒ ã‚¨ãƒ©ãƒ¼: " + e.message;
      status.style.color = "#f55";
    }
  }, 20);
}

function runTest() {
  if(!finalCode) return;
  try {
    const log = console.log;
    let output = "";
    console.log = (...args) => { output += args.join(' ') + "\n"; log(...args); };
    
    new Function(finalCode)();
    
    console.log = log;
    alert(output ? "å®Ÿè¡ŒæˆåŠŸï¼ãƒ­ã‚°:\n" + output : "å®Ÿè¡ŒæˆåŠŸï¼(ãƒ­ã‚°ãªã—)");
  } catch(e) {
    alert("å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼:\n" + e.message);
  }
}

function copyToClip() {
  navigator.clipboard.writeText(finalCode);
  document.getElementById('statusText').textContent = "ã‚³ãƒ”ãƒ¼å®Œäº†";
}

document.getElementById('layers').addEventListener('input', e => document.getElementById('layerVal').textContent = e.target.value);
</script>
</body>
</html>
