<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高機能 JavaScript 難読化・圧縮ツール (自己完結型)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; margin: 0; background-color: #f6f8fa; }
        .header { background-color: #24292e; color: white; padding: 16px; text-align: center; }
        .main-container { display: flex; flex-direction: column; padding: 16px; gap: 16px; }
        .io-container { display: flex; flex-direction: column; gap: 16px; height: 60vh; }
        @media (min-width: 768px) { .io-container { flex-direction: row; } }
        .textarea-wrapper { position: relative; width: 100%; height: 100%; }
        textarea { width: 100%; height: 100%; box-sizing: border-box; font-family: monospace; font-size: 14px; border: 1px solid #d1d5da; border-radius: 6px; padding: 8px; resize: vertical; }
        .copy-button { position: absolute; top: 8px; right: 8px; z-index: 10; padding: 4px 10px; font-size: 12px; background-color: #f6f8fa; border: 1px solid #d1d5da; border-radius: 6px; cursor: pointer; opacity: 0.8; transition: all 0.2s; }
        .copy-button:hover { background-color: #e1e4e8; opacity: 1; }
        .copy-button:disabled { background-color: #2ea44f; color: white; border-color: #2ea44f; }
        .options-container { background-color: white; border: 1px solid #d1d5da; border-radius: 6px; padding: 16px; }
        .options-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; align-items: center;}
        .option-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-weight: 600; }
        select, button { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5da; font-size: 14px; }
        .process-button { background-color: #2ea44f; color: white; font-weight: 600; cursor: pointer; border-color: #2ea44f; }
        .process-button:hover:not(:disabled) { background-color: #2c974b; }
        .process-button:disabled { background-color: #94d3a2; cursor: not-allowed; }
        .result-info { margin-top: 16px; background-color: #eef5ff; padding: 16px; border-radius: 6px; border: 1px solid #c8d9f5; }
        .result-info strong { font-size: 1.2em; }
        .warning { color: #d73a49; font-weight: bold; }
        .success { color: #2ea44f; font-weight: bold; }
    </style>
    <!-- 外部ライブラリを読み込むのはこのツールページ自体だけ。出力結果はライブラリに依存しない -->
    <script src="https://cdn.jsdelivr.net/npm/terser/dist/bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/javascript-obfuscator@4.1.0/dist/index.browser.js"></script>
</head>
<body>
    <header class="header"><h1>高機能 JavaScript 難読化・圧縮ツール (自己完結型)</h1></header>

    <main class="main-container">
        <div class="io-container">
            <div class="textarea-wrapper"><textarea id="input-code" placeholder="ここにJavaScriptコードを入力..."></textarea></div>
            <div class="textarea-wrapper">
                <textarea id="output-code" readonly placeholder="処理結果がここに出力されます..."></textarea>
                <button id="copy-btn" class="copy-button">コピー</button>
            </div>
        </div>

        <div class="options-container">
            <div class="options-grid">
                <div class="option-group"><label for="use-terser">1. Terser 圧縮</label><select id="use-terser"><option value="yes" selected>有効</option><option value="no">無効</option></select></div>
                <div class="option-group"><label for="obfuscator-preset">2. 難読化レベル</label><select id="obfuscator-preset"><option value="low">低 (サイズ重視)</option><option value="medium" selected>中 (バランス)</option><option value="high">高 (難読化重視)</option></select></div>
                <div class="option-group">
                    <label for="encoding-type">3. 最終エンコード</label>
                    <select id="encoding-type">
                        <option value="none" selected>なし</option>
                        <option value="base85">Custom Base85 (高圧縮 / 自己完結)</option>
                    </select>
                </div>
                <div class="option-group"><label>&nbsp;</label><button id="process-btn" class="process-button">処理を実行</button></div>
            </div>
        </div>

        <div id="result-info" class="result-info">結果はここに表示されます。</div>
    </main>

    <script>
        // --- 自己完結型エンコーダーのロジック ---

        // 1. 文字列をUTF-8のバイト配列に変換 (Unicode対応のため)
        const utf8Encode = (str) => {
            const bytes = [];
            for (let i = 0; i < str.length; i++) {
                let charCode = str.charCodeAt(i);
                if (charCode < 0x80) {
                    bytes.push(charCode);
                } else if (charCode < 0x800) {
                    bytes.push(0xc0 | (charCode >> 6), 0x80 | (charCode & 0x3f));
                } else if (charCode < 0x10000) {
                    bytes.push(0xe0 | (charCode >> 12), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
                } else {
                    bytes.push(0xf0 | (charCode >> 18), 0x80 | ((charCode >> 12) & 0x3f), 0x80 | ((charCode >> 6) & 0x3f), 0x80 | (charCode & 0x3f));
                }
            }
            return bytes;
        };

        // 2. バイト配列をBase85文字列にエンコード
        const base85Encode = (bytes) => {
            let result = '', i = 0;
            const alphabet = '!"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu'; // 85 chars
            for (i = 0; i + 3 < bytes.length; i += 4) {
                let chunk = (bytes[i] << 24) | (bytes[i+1] << 16) | (bytes[i+2] << 8) | bytes[i+3];
                let block = [];
                for (let j = 0; j < 5; j++) {
                    block.unshift(alphabet[chunk % 85]);
                    chunk = Math.floor(chunk / 85);
                }
                result += block.join('');
            }
            // 末尾の余りを処理
            if (i < bytes.length) {
                let remaining = bytes.length - i;
                let chunk = 0;
                for (let j = 0; j < remaining; j++) chunk |= bytes[i + j] << (8 * (3 - j));
                let block = [];
                for (let j = 0; j < 5; j++) {
                    block.unshift(alphabet[chunk % 85]);
                    chunk = Math.floor(chunk / 85);
                }
                result += block.join('').substring(0, remaining + 1);
            }
            return result;
        };
        
        // --- UI とメインロジック ---

        const processBtn = document.getElementById('process-btn');
        const copyBtn = document.getElementById('copy-btn');
        const inputArea = document.getElementById('input-code');
        const outputArea = document.getElementById('output-code');
        const resultInfo = document.getElementById('result-info');

        copyBtn.addEventListener('click', () => { /* ... (変更なし) ... */ });

        processBtn.addEventListener('click', async () => {
            if (!inputArea.value.trim()) { /* ... (変更なし) ... */ return; }
            processBtn.disabled = true; processBtn.textContent = '処理中...';
            outputArea.value = ''; resultInfo.innerHTML = '処理を開始します...';
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                let processedCode = inputArea.value;
                const originalSize = new Blob([processedCode]).size;

                if (document.getElementById('use-terser').value === 'yes') { /* ... (変更なし) ... */ }
                const preset = document.getElementById('obfuscator-preset').value;
                if (preset !== 'none') { /* ... (変更なし) ... */ }

                const encodingType = document.getElementById('encoding-type').value;
                if (encodingType === 'base85') {
                    // ★★★ 新しい自己完結型エンコード処理 ★★★
                    const utf8Bytes = utf8Encode(processedCode);
                    const encodedData = base85Encode(utf8Bytes);
                    
                    // 自己完結型のデコーダー（最小化済み）を生成
                    const decoder = `(d=>{let r=[],c=0,p=0,i=0;const A='!"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\`abcdefghijklmnopqrstu';for(i=0;i<d.length;i++){c=A.indexOf(d[i]);if(c<0)continue;p=p*85+c;if(i%5==4){r.push(p>>24&255,p>>16&255,p>>8&255,p&255);p=0}}let t=d.length%5;if(t){t--;for(i=0;i<4-t;i++)p=p*85+84;for(i=0;i<t;i++)r.push(p>>24-i*8&255)}let s='';for(i=0;i<r.length;){let a=r[i++];if(a<128)s+=String.fromCharCode(a);else if(a>191&&a<224)s+=String.fromCharCode((a&31)<<6|r[i++]&63);else s+=String.fromCharCode((a&15)<<12|(r[i++]&63)<<6|r[i++]&63)}new (()=>{})["constructor"](s)()})`;
                    
                    processedCode = `${decoder}('${encodedData}')`;
                }
                
                const finalSize = new Blob([processedCode]).size;
                const ratio = finalSize > 0 ? (finalSize / originalSize) : 0;
                outputArea.value = processedCode;
                
                let resultHTML = `元のサイズ: ${originalSize.toLocaleString()} バイト<br>出力サイズ: ${finalSize.toLocaleString()} バイト<br>サイズ比: <strong>${ratio.toFixed(2)} 倍</strong>`;
                if (ratio > 1.6) { /* ... (変更なし) ... */ }
                else if (finalSize > 0) { /* ... (変更なし) ... */ }
                resultInfo.innerHTML = resultHTML;

            } catch (e) { /* ... (変更なし) ... */ }
            finally { /* ... (変更なし) ... */ }
        });

        // --- 以下の部分は前のコードからコピー ---
        copyBtn.addEventListener('click', () => { const codeToCopy=outputArea.value; if(!codeToCopy)return; navigator.clipboard.writeText(codeToCopy).then(()=>{copyBtn.textContent='コピーしました！';copyBtn.disabled=true;setTimeout(()=>{copyBtn.textContent='コピー';copyBtn.disabled=false},2000)})});
        processBtn.addEventListener('click', async () => { if(!inputArea.value.trim()){resultInfo.innerHTML="コードを入力してから実行してください。";return} processBtn.disabled=true;processBtn.textContent='処理中...';outputArea.value='';resultInfo.innerHTML='処理を開始します...';await new Promise(resolve=>setTimeout(resolve,50));try{let processedCode=inputArea.value;const originalSize=new Blob([processedCode]).size;if(document.getElementById('use-terser').value==='yes'){const terserResult=await Terser.minify(processedCode,{mangle:{toplevel:true}});if(terserResult.error)throw terserResult.error;processedCode=terserResult.code} const preset=document.getElementById('obfuscator-preset').value;if(preset!=='none'){const options=getObfuscatorOptions(preset);processedCode=JavaScriptObfuscator.obfuscate(processedCode,options).getObfuscatedCode()} const encodingType=document.getElementById('encoding-type').value;if(encodingType==='base85'){const utf8Bytes=utf8Encode(processedCode);const encodedData=base85Encode(utf8Bytes);const decoder=`(d=>{let r=[],c=0,p=0,i=0;const A='!"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\`abcdefghijklmnopqrstu';for(i=0;i<d.length;i++){c=A.indexOf(d[i]);if(c<0)continue;p=p*85+c;if(i%5==4){r.push(p>>24&255,p>>16&255,p>>8&255,p&255);p=0}}let t=d.length%5;if(t){t--;for(i=0;i<4-t;i++)p=p*85+84;for(i=0;i<t;i++)r.push(p>>24-i*8&255)}let s='';for(i=0;i<r.length;){let a=r[i++];if(a<128)s+=String.fromCharCode(a);else if(a>191&&a<224)s+=String.fromCharCode((a&31)<<6|r[i++]&63);else s+=String.fromCharCode((a&15)<<12|(r[i++]&63)<<6|r[i++]&63)}new (()=>{})["constructor"](s)()})`;processedCode=`${decoder}('${encodedData}')`} const finalSize=new Blob([processedCode]).size;const ratio=finalSize>0?(finalSize/originalSize):0;outputArea.value=processedCode;let resultHTML=`元のサイズ: ${originalSize.toLocaleString()} バイト<br>出力サイズ: ${finalSize.toLocaleString()} バイト<br>サイズ比: <strong>${ratio.toFixed(2)} 倍</strong>`;if(ratio>1.6){resultHTML+=`<br><span class="warning">警告: 目標の1.6倍を超えました。難読化レベルを下げてみてください。</span>`}else if(finalSize>0){resultHTML+=`<br><span class="success">目標の1.6倍以内に収まっています！</span>`} resultInfo.innerHTML=resultHTML}catch(e){const errorMessage=`エラー: ${e.message}\n\nLine: ${e.line}, Col: ${e.col}, Pos: ${e.pos}`;outputArea.value=errorMessage;resultInfo.innerHTML=`<span class="warning">処理中にエラーが発生しました。</span>`;console.error(e)}finally{processBtn.disabled=false;processBtn.textContent='処理を実行'}})
        function getObfuscatorOptions(preset) { /* ... (変更なし) ... */ }
        function getObfuscatorOptions(preset){switch(preset){case'high':return{compact:true,controlFlowFlattening:true,controlFlowFlatteningThreshold:1,deadCodeInjection:true,deadCodeInjectionThreshold:1,debugProtection:true,disableConsoleOutput:true,selfDefending:true,stringArray:true,stringArrayEncoding:['base64'],rotateStringArray:true,transformObjectKeys:true,unicodeEscapeSequence:true};case'medium':return{compact:true,controlFlowFlattening:true,controlFlowFlatteningThreshold:0.75,deadCodeInjection:true,deadCodeInjectionThreshold:0.4,debugProtection:false,disableConsoleOutput:true,selfDefending:true,stringArray:true,stringArrayThreshold:0.75,rotateStringArray:true,};default:return{compact:true,simplify:true,stringArray:true,stringArrayThreshold:0.75,splitStrings:true,splitStringsChunkLength:10,}}}
    </script>
</body>
</html>
